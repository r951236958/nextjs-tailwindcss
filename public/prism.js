/* PrismJS 1.22.0
https://prismjs.com/download.html#themes=prism-okaidia&languages=markup+css+clike+javascript+jsx&plugins=autoloader+toolbar+copy-to-clipboard */
const _self = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : {}; const Prism = (function (u) {
  const c = /\blang(?:uage)?-([\w-]+)\b/i; let n = 0; var M = {
    manual: u.Prism && u.Prism.manual,
    disableWorkerMessageHandler: u.Prism && u.Prism.disableWorkerMessageHandler,
    util: {
      encode: function e(n) { return n instanceof W ? new W(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' '); }, type(e) { return Object.prototype.toString.call(e).slice(8, -1); }, objId(e) { return e.__id || Object.defineProperty(e, '__id', { value: ++n }), e.__id; }, clone: function t(e, r) { let a; let n; switch (r = r || {}, M.util.type(e)) { case 'Object': if (n = M.util.objId(e), r[n]) return r[n]; for (const i in a = {}, r[n] = a, e)e.hasOwnProperty(i) && (a[i] = t(e[i], r)); return a; case 'Array': return n = M.util.objId(e), r[n] ? r[n] : (a = [], r[n] = a, e.forEach((e, n) => { a[n] = t(e, r); }), a); default: return e; } }, getLanguage(e) { for (;e && !c.test(e.className);)e = e.parentElement; return e ? (e.className.match(c) || [, 'none'])[1].toLowerCase() : 'none'; }, currentScript() { if (typeof document === 'undefined') return null; if ('currentScript' in document) return document.currentScript; try { throw new Error(); } catch (e) { const n = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(e.stack) || [])[1]; if (n) { const t = document.getElementsByTagName('script'); for (const r in t) if (t[r].src == n) return t[r]; } return null; } }, isActive(e, n, t) { for (let r = `no-${n}`; e;) { const a = e.classList; if (a.contains(n)) return !0; if (a.contains(r)) return !1; e = e.parentElement; } return !!t; },
    },
    languages: { extend(e, n) { const t = M.util.clone(M.languages[e]); for (const r in n)t[r] = n[r]; return t; }, insertBefore(t, e, n, r) { const a = (r = r || M.languages)[t]; const i = {}; for (const l in a) if (a.hasOwnProperty(l)) { if (l == e) for (const o in n)n.hasOwnProperty(o) && (i[o] = n[o]); n.hasOwnProperty(l) || (i[l] = a[l]); } const s = r[t]; return r[t] = i, M.languages.DFS(M.languages, function (e, n) { n === s && e != t && (this[e] = i); }), i; }, DFS: function e(n, t, r, a) { a = a || {}; const i = M.util.objId; for (const l in n) if (n.hasOwnProperty(l)) { t.call(n, l, n[l], r || l); const o = n[l]; const s = M.util.type(o); s !== 'Object' || a[i(o)] ? s !== 'Array' || a[i(o)] || (a[i(o)] = !0, e(o, t, l, a)) : (a[i(o)] = !0, e(o, t, null, a)); } } },
    plugins: {},
    highlightAll(e, n) { M.highlightAllUnder(document, e, n); },
    highlightAllUnder(e, n, t) { const r = { callback: t, container: e, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; M.hooks.run('before-highlightall', r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), M.hooks.run('before-all-elements-highlight', r); for (var a, i = 0; a = r.elements[i++];)M.highlightElement(a, !0 === n, r.callback); },
    highlightElement(e, n, t) {
      const r = M.util.getLanguage(e); const a = M.languages[r]; e.className = `${e.className.replace(c, '').replace(/\s+/g, ' ')} language-${r}`; const i = e.parentElement; i && i.nodeName.toLowerCase() === 'pre' && (i.className = `${i.className.replace(c, '').replace(/\s+/g, ' ')} language-${r}`); const l = {
        element: e, language: r, grammar: a, code: e.textContent,
      }; function o(e) { l.highlightedCode = e, M.hooks.run('before-insert', l), l.element.innerHTML = l.highlightedCode, M.hooks.run('after-highlight', l), M.hooks.run('complete', l), t && t.call(l.element); } if (M.hooks.run('before-sanity-check', l), !l.code) return M.hooks.run('complete', l), void (t && t.call(l.element)); if (M.hooks.run('before-highlight', l), l.grammar) if (n && u.Worker) { const s = new Worker(M.filename); s.onmessage = function (e) { o(e.data); }, s.postMessage(JSON.stringify({ language: l.language, code: l.code, immediateClose: !0 })); } else o(M.highlight(l.code, l.grammar, l.language)); else o(M.util.encode(l.code));
    },
    highlight(e, n, t) { const r = { code: e, grammar: n, language: t }; return M.hooks.run('before-tokenize', r), r.tokens = M.tokenize(r.code, r.grammar), M.hooks.run('after-tokenize', r), W.stringify(M.util.encode(r.tokens), r.language); },
    tokenize(e, n) { const t = n.rest; if (t) { for (const r in t)n[r] = t[r]; delete n.rest; } const a = new i(); return I(a, a.head, e), (function e(n, t, r, a, i, l) { for (const o in r) if (r.hasOwnProperty(o) && r[o]) { let s = r[o]; s = Array.isArray(s) ? s : [s]; for (let u = 0; u < s.length; ++u) { if (l && l.cause == `${o},${u}`) return; const c = s[u]; const g = c.inside; const f = !!c.lookbehind; const h = !!c.greedy; let d = 0; const v = c.alias; if (h && !c.pattern.global) { const p = c.pattern.toString().match(/[imsuy]*$/)[0]; c.pattern = RegExp(c.pattern.source, `${p}g`); } for (let m = c.pattern || c, y = a.next, k = i; y !== t.tail && !(l && k >= l.reach); k += y.value.length, y = y.next) { let b = y.value; if (t.length > n.length) return; if (!(b instanceof W)) { let x = 1; if (h && y != t.tail.prev) { m.lastIndex = k; var w = m.exec(n); if (!w) break; var A = w.index + (f && w[1] ? w[1].length : 0); var P = w.index + w[0].length; let S = k; for (S += y.value.length; S <= A;)y = y.next, S += y.value.length; if (S -= y.value.length, k = S, y.value instanceof W) continue; for (let E = y; E !== t.tail && (S < P || typeof E.value === 'string'); E = E.next)x++, S += E.value.length; x--, b = n.slice(k, S), w.index -= k; } else { m.lastIndex = 0; var w = m.exec(b); } if (w) { f && (d = w[1] ? w[1].length : 0); var A = w.index + d; const O = w[0].slice(d); var P = A + O.length; const L = b.slice(0, A); const N = b.slice(P); const j = k + b.length; l && j > l.reach && (l.reach = j); let C = y.prev; L && (C = I(t, C, L), k += L.length), z(t, C, x); const _ = new W(o, g ? M.tokenize(O, g) : O, v, O); y = I(t, C, _), N && I(t, y, N), x > 1 && e(n, t, r, y.prev, k, { cause: `${o},${u}`, reach: j }); } } } } } }(e, a, n, a.head, 0)), (function (e) { const n = []; let t = e.head.next; for (;t !== e.tail;)n.push(t.value), t = t.next; return n; }(a)); },
    hooks: { all: {}, add(e, n) { const t = M.hooks.all; t[e] = t[e] || [], t[e].push(n); }, run(e, n) { const t = M.hooks.all[e]; if (t && t.length) for (var r, a = 0; r = t[a++];)r(n); } },
    Token: W,
  }; function W(e, n, t, r) { this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || '').length; } function i() { const e = { value: null, prev: null, next: null }; const n = { value: null, prev: e, next: null }; e.next = n, this.head = e, this.tail = n, this.length = 0; } function I(e, n, t) { const r = n.next; const a = { value: t, prev: n, next: r }; return n.next = a, r.prev = a, e.length++, a; } function z(e, n, t) { for (var r = n.next, a = 0; a < t && r !== e.tail; a++)r = r.next; (n.next = r).prev = n, e.length -= a; } if (u.Prism = M, W.stringify = function n(e, t) {
    if (typeof e === 'string') return e; if (Array.isArray(e)) { let r = ''; return e.forEach((e) => { r += n(e, t); }), r; } const a = {
      type: e.type, content: n(e.content, t), tag: 'span', classes: ['token', e.type], attributes: {}, language: t,
    }; const i = e.alias; i && (Array.isArray(i) ? Array.prototype.push.apply(a.classes, i) : a.classes.push(i)), M.hooks.run('wrap', a); let l = ''; for (const o in a.attributes)l += ` ${o}="${(a.attributes[o] || '').replace(/"/g, '&quot;')}"`; return `<${a.tag} class="${a.classes.join(' ')}"${l}>${a.content}</${a.tag}>`;
  }, !u.document) return u.addEventListener && (M.disableWorkerMessageHandler || u.addEventListener('message', (e) => { const n = JSON.parse(e.data); const t = n.language; const r = n.code; const a = n.immediateClose; u.postMessage(M.highlight(r, M.languages[t], t)), a && u.close(); }, !1)), M; const e = M.util.currentScript(); function t() { M.manual || M.highlightAll(); } if (e && (M.filename = e.src, e.hasAttribute('data-manual') && (M.manual = !0)), !M.manual) { const r = document.readyState; r === 'loading' || r === 'interactive' && e && e.defer ? document.addEventListener('DOMContentLoaded', t) : window.requestAnimationFrame ? window.requestAnimationFrame(t) : window.setTimeout(t, 16); } return M;
}(_self)); typeof module !== 'undefined' && module.exports && (module.exports = Prism), typeof global !== 'undefined' && (global.Prism = Prism);
Prism.languages.markup = {
  comment: /<!--[\s\S]*?-->/,
  prolog: /<\?[\s\S]+?\?>/,
  doctype: {
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      'internal-subset': {
        pattern: /(\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null,
      },
      string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
      punctuation: /^<!|>$|[[\]]/,
      'doctype-tag': /^DOCTYPE/,
      name: /[^\s<>'"]+/,
    },
  },
  cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, 'attr-value': { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: 'attr-equals' }, /"|'/] } }, punctuation: /\/?>/, 'attr-name': { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
    },
  },
  entity: [{ pattern: /&[\da-z]{1,8};/i, alias: 'named-entity' }, /&#x?[\da-f]{1,8};/i],
}, Prism.languages.markup.tag.inside['attr-value'].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside['internal-subset'].inside = Prism.languages.markup, Prism.hooks.add('wrap', (a) => { a.type === 'entity' && (a.attributes.title = a.content.replace(/&amp;/, '&')); }), Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
  value(a, e) {
    const s = {}; s[`language-${e}`] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[e] }, s.cdata = /^<!\[CDATA\[|\]\]>$/i; const n = { 'included-cdata': { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: s } }; n[`language-${e}`] = { pattern: /[\s\S]+/, inside: Prism.languages[e] }; const t = {}; t[a] = {
      pattern: RegExp('(<__[^]*?>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[^])*?(?=</__>)'.replace(/__/g, () => a), 'i'), lookbehind: !0, greedy: !0, inside: n,
    }, Prism.languages.insertBefore('markup', 'cdata', t);
  },
}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend('markup', {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;
!(function (e) {
  const t = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/; e.languages.css = {
    comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/, inside: { rule: /^@[\w-]+/, 'selector-function-argument': { pattern: /(\bselector\s*\((?!\s*\))\s*)(?:[^()]|\((?:[^()]|\([^()]*\))*\))+?(?=\s*\))/, lookbehind: !0, alias: 'selector' }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 } } }, url: { pattern: RegExp(`\\burl\\((?:${t.source}|(?:[^\\\\\r\n()"']|\\\\[^])*)\\)`, 'i'), greedy: !0, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp(`^${t.source}$`), alias: 'url' } } }, selector: RegExp(`[^{}\\s](?:[^{};"']|${t.source})*?(?=\\s*\\{)`), string: { pattern: t, greedy: !0 }, property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i, important: /!important\b/i, function: /[-a-z0-9]+(?=\()/i, punctuation: /[(){};:,]/,
  }, e.languages.css.atrule.inside.rest = e.languages.css; const s = e.languages.markup; s && (s.tag.addInlined('style', 'css'), e.languages.insertBefore('inside', 'attr-value', {
    'style-attr': {
      pattern: /(^|["'\s])style\s*=\s*(?:"[^"]*"|'[^']*')/i,
      lookbehind: !0,
      inside: {
        'attr-value': {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            style: {
              pattern: /(["'])[\s\S]+(?=["']$)/, lookbehind: !0, alias: 'language-css', inside: e.languages.css,
            },
            punctuation: [{ pattern: /^=/, alias: 'attr-equals' }, /"|'/],
          },
        },
        'attr-name': /^style/i,
      },
    },
  }, s.tag));
}(Prism));
Prism.languages.clike = {
  comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, 'class-name': { pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/,
};
Prism.languages.javascript = Prism.languages.extend('clike', {
  'class-name': [Prism.languages.clike['class-name'], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: !0 }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: !0 }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: !0 }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
}), Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, Prism.languages.insertBefore('javascript', 'keyword', {
  regex: {
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
    lookbehind: !0,
    greedy: !0,
    inside: {
      'regex-source': {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: 'language-regex', inside: Prism.languages.regex,
      },
      'regex-flags': /[a-z]+$/,
      'regex-delimiter': /^\/|\/$/,
    },
  },
  'function-variable': { pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: 'function' },
  parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: !0, inside: Prism.languages.javascript }],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
}), Prism.languages.insertBefore('javascript', 'string', { 'template-string': { pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/, greedy: !0, inside: { 'template-punctuation': { pattern: /^`|`$/, alias: 'string' }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/, lookbehind: !0, inside: { 'interpolation-punctuation': { pattern: /^\${|}$/, alias: 'punctuation' }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } } }), Prism.languages.markup && Prism.languages.markup.tag.addInlined('script', 'javascript'), Prism.languages.js = Prism.languages.javascript;
!(function (i) { const t = i.util.clone(i.languages.javascript); i.languages.jsx = i.languages.extend('markup', t), i.languages.jsx.tag.pattern = /<\/?(?:[\w.:-]+\s*(?:\s+(?:[\w.:$-]+(?:=(?:"(?:\\[^]|[^\\"])*"|'(?:\\[^]|[^\\'])*'|[^\s{'">=]+|\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}))?|\{\s*\.{3}\s*[a-z_$][\w$]*(?:\.[a-z_$][\w$]*)*\s*\}))*\s*\/?)?>/i, i.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/i, i.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\{)(?:"(?:\\[^]|[^\\"])*"|'(?:\\[^]|[^\\'])*'|[^\s'">]+)/i, i.languages.jsx.tag.inside.tag.inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, i.languages.insertBefore('inside', 'attr-name', { spread: { pattern: /\{\s*\.{3}\s*[a-z_$][\w$]*(?:\.[a-z_$][\w$]*)*\s*\}/, inside: { punctuation: /\.{3}|[{}.]/, 'attr-value': /\w+/ } } }, i.languages.jsx.tag), i.languages.insertBefore('inside', 'attr-value', { script: { pattern: /=(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\})/i, inside: { 'script-punctuation': { pattern: /^=(?={)/, alias: 'punctuation' }, rest: i.languages.jsx }, alias: 'language-javascript' } }, i.languages.jsx.tag); var o = function (t) { return t ? typeof t === 'string' ? t : typeof t.content === 'string' ? t.content : t.content.map(o).join('') : ''; }; var p = function (t) { for (let n = [], e = 0; e < t.length; e++) { const a = t[e]; let s = !1; if (typeof a !== 'string' && (a.type === 'tag' && a.content[0] && a.content[0].type === 'tag' ? a.content[0].content[0].content === '</' ? n.length > 0 && n[n.length - 1].tagName === o(a.content[0].content[1]) && n.pop() : a.content[a.content.length - 1].content === '/>' || n.push({ tagName: o(a.content[0].content[1]), openedBraces: 0 }) : n.length > 0 && a.type === 'punctuation' && a.content === '{' ? n[n.length - 1].openedBraces++ : n.length > 0 && n[n.length - 1].openedBraces > 0 && a.type === 'punctuation' && a.content === '}' ? n[n.length - 1].openedBraces-- : s = !0), (s || typeof a === 'string') && n.length > 0 && n[n.length - 1].openedBraces === 0) { let g = o(a); e < t.length - 1 && (typeof t[e + 1] === 'string' || t[e + 1].type === 'plain-text') && (g += o(t[e + 1]), t.splice(e + 1, 1)), e > 0 && (typeof t[e - 1] === 'string' || t[e - 1].type === 'plain-text') && (g = o(t[e - 1]) + g, t.splice(e - 1, 1), e--), t[e] = new i.Token('plain-text', g, null, g); }a.content && typeof a.content !== 'string' && p(a.content); } }; i.hooks.add('after-tokenize', (t) => { t.language !== 'jsx' && t.language !== 'tsx' || p(t.tokens); }); }(Prism));
!(function () {
  if (typeof self !== 'undefined' && self.Prism && self.document && document.createElement) {
    var l = {
      javascript: 'clike', actionscript: 'javascript', apex: ['clike', 'sql'], arduino: 'cpp', aspnet: ['markup', 'csharp'], birb: 'clike', bison: 'c', c: 'clike', csharp: 'clike', cpp: 'c', coffeescript: 'javascript', crystal: 'ruby', 'css-extras': 'css', d: 'clike', dart: 'clike', django: 'markup-templating', ejs: ['javascript', 'markup-templating'], etlua: ['lua', 'markup-templating'], erb: ['ruby', 'markup-templating'], fsharp: 'clike', 'firestore-security-rules': 'clike', flow: 'javascript', ftl: 'markup-templating', gml: 'clike', glsl: 'c', go: 'clike', groovy: 'clike', haml: 'ruby', handlebars: 'markup-templating', haxe: 'clike', hlsl: 'c', java: 'clike', javadoc: ['markup', 'java', 'javadoclike'], jolie: 'clike', jsdoc: ['javascript', 'javadoclike', 'typescript'], 'js-extras': 'javascript', json5: 'json', jsonp: 'json', 'js-templates': 'javascript', kotlin: 'clike', latte: ['clike', 'markup-templating', 'php'], less: 'css', lilypond: 'scheme', markdown: 'markup', 'markup-templating': 'markup', mongodb: 'javascript', n4js: 'javascript', nginx: 'clike', objectivec: 'c', opencl: 'c', parser: 'markup', php: 'markup-templating', phpdoc: ['php', 'javadoclike'], 'php-extras': 'php', plsql: 'sql', processing: 'clike', protobuf: 'clike', pug: ['markup', 'javascript'], purebasic: 'clike', purescript: 'haskell', qml: 'javascript', qore: 'clike', racket: 'scheme', jsx: ['markup', 'javascript'], tsx: ['jsx', 'typescript'], reason: 'clike', ruby: 'clike', sass: 'css', scss: 'css', scala: 'java', 'shell-session': 'bash', smarty: 'markup-templating', solidity: 'clike', soy: 'markup-templating', sparql: 'turtle', sqf: 'clike', swift: 'clike', 't4-cs': ['t4-templating', 'csharp'], 't4-vb': ['t4-templating', 'vbnet'], tap: 'yaml', tt2: ['clike', 'markup-templating'], textile: 'markup', twig: 'markup', typescript: 'javascript', vala: 'clike', vbnet: 'basic', velocity: 'markup', wiki: 'markup', xeora: 'markup', 'xml-doc': 'markup', xquery: 'markup',
    }; var n = {
      html: 'markup', xml: 'markup', svg: 'markup', mathml: 'markup', ssml: 'markup', atom: 'markup', rss: 'markup', js: 'javascript', g4: 'antlr4', adoc: 'asciidoc', shell: 'bash', shortcode: 'bbcode', rbnf: 'bnf', oscript: 'bsl', cs: 'csharp', dotnet: 'csharp', coffee: 'coffeescript', conc: 'concurnas', jinja2: 'django', 'dns-zone': 'dns-zone-file', dockerfile: 'docker', eta: 'ejs', xlsx: 'excel-formula', xls: 'excel-formula', gamemakerlanguage: 'gml', hs: 'haskell', gitignore: 'ignore', hgignore: 'ignore', npmignore: 'ignore', webmanifest: 'json', kt: 'kotlin', kts: 'kotlin', tex: 'latex', context: 'latex', ly: 'lilypond', emacs: 'lisp', elisp: 'lisp', 'emacs-lisp': 'lisp', md: 'markdown', moon: 'moonscript', n4jsd: 'n4js', nani: 'naniscript', objc: 'objectivec', objectpascal: 'pascal', px: 'pcaxis', pcode: 'peoplecode', pq: 'powerquery', mscript: 'powerquery', pbfasm: 'purebasic', purs: 'purescript', py: 'python', rkt: 'racket', rpy: 'renpy', robot: 'robotframework', rb: 'ruby', 'sh-session': 'shell-session', shellsession: 'shell-session', smlnj: 'sml', sol: 'solidity', sln: 'solution-file', rq: 'sparql', t4: 't4-cs', trig: 'turtle', ts: 'typescript', tsconfig: 'typoscript', uscript: 'unrealscript', uc: 'unrealscript', vb: 'visual-basic', vba: 'visual-basic', xeoracube: 'xeora', yml: 'yaml',
    }; var p = {}; let e = 'components/'; const a = Prism.util.currentScript(); if (a) { const r = /\bplugins\/autoloader\/prism-autoloader\.(?:min\.)?js(?:\?[^\r\n/]*)?$/i; const s = /(^|\/)[\w-]+\.(?:min\.)?js(?:\?[^\r\n/]*)?$/i; const t = a.getAttribute('data-autoloader-path'); if (t != null)e = t.trim().replace(/\/?$/, '/'); else { const i = a.src; r.test(i) ? e = i.replace(r, 'components/') : s.test(i) && (e = i.replace(s, '$1components/')); } } var o = Prism.plugins.autoloader = { languages_path: e, use_minified: !0, loadLanguages: m }; Prism.hooks.add('complete', (e) => { const a = e.element; const r = e.language; if (a && r && r !== 'none') { const s = (function (e) { let a = (e.getAttribute('data-dependencies') || '').trim(); if (!a) { const r = e.parentElement; r && r.tagName.toLowerCase() === 'pre' && (a = (r.getAttribute('data-dependencies') || '').trim()); } return a ? a.split(/\s*,\s*/g) : []; }(a)); /^diff-./i.test(r) ? (s.push('diff'), s.push(r.substr('diff-'.length))) : s.push(r), s.every(u) || m(s, () => { Prism.highlightElement(a); }); } });
  } function u(e) { if (e.indexOf('!') >= 0) return !1; if ((e = n[e] || e) in Prism.languages) return !0; const a = p[e]; return a && !a.error && !1 === a.loading; } function m(e, a, r) { typeof e === 'string' && (e = [e]); const s = e.length; let t = 0; let i = !1; function c() { i || ++t === s && a && a(e); }s !== 0 ? e.forEach((e) => { !(function (a, r, s) { const t = a.indexOf('!') >= 0; function e() { let e = p[a]; e || (e = p[a] = { callbacks: [] }), e.callbacks.push({ success: r, error: s }), !t && u(a) ? k(a, 'success') : !t && e.error ? k(a, 'error') : !t && e.loading || (e.loading = !0, e.error = !1, (function (e, a, r) { const s = document.createElement('script'); s.src = e, s.async = !0, s.onload = function () { document.body.removeChild(s), a && a(); }, s.onerror = function () { document.body.removeChild(s), r && r(); }, document.body.appendChild(s); }((function (e) { return `${o.languages_path}prism-${e}${o.use_minified ? '.min' : ''}.js`; }(a)), () => { e.loading = !1, k(a, 'success'); }, () => { e.loading = !1, e.error = !0, k(a, 'error'); }))); }a = a.replace('!', ''), a = n[a] || a; const i = l[a]; i && i.length ? m(i, e, s) : e(); }(e, c, () => { i || (i = !0, r && r(e)); })); }) : a && setTimeout(a, 0); } function k(e, a) { if (p[e]) { for (var r = p[e].callbacks, s = 0, t = r.length; s < t; s++) { const i = r[s][a]; i && setTimeout(i, 0); }r.length = 0; } }
}());
!(function () { if (typeof self !== 'undefined' && self.Prism && self.document) { const i = []; const l = {}; const c = function () {}; Prism.plugins.toolbar = {}; const e = Prism.plugins.toolbar.registerButton = function (e, n) { let t; t = typeof n === 'function' ? n : function (e) { let t; return typeof n.onClick === 'function' ? ((t = document.createElement('button')).type = 'button', t.addEventListener('click', function () { n.onClick.call(this, e); })) : typeof n.url === 'string' ? (t = document.createElement('a')).href = n.url : t = document.createElement('span'), n.className && t.classList.add(n.className), t.textContent = n.text, t; }, e in l ? console.warn(`There is a button with the key "${e}" registered already.`) : i.push(l[e] = t); }; const t = Prism.plugins.toolbar.hook = function (a) { const e = a.element.parentNode; if (e && /pre/i.test(e.nodeName) && !e.parentNode.classList.contains('code-toolbar')) { const t = document.createElement('div'); t.classList.add('code-toolbar'), e.parentNode.insertBefore(t, e), t.appendChild(e); const r = document.createElement('div'); r.classList.add('toolbar'); let n = i; const o = (function (e) { for (;e;) { let t = e.getAttribute('data-toolbar-order'); if (t != null) return (t = t.trim()).length ? t.split(/\s*,\s*/g) : []; e = e.parentElement; } }(a.element)); o && (n = o.map((e) => l[e] || c)), n.forEach((e) => { const t = e(a); if (t) { const n = document.createElement('div'); n.classList.add('toolbar-item'), n.appendChild(t), r.appendChild(n); } }), t.appendChild(r); } }; e('label', (e) => { const t = e.element.parentNode; if (t && /pre/i.test(t.nodeName) && t.hasAttribute('data-label')) { let n; let a; const r = t.getAttribute('data-label'); try { a = document.querySelector(`template#${r}`); } catch (e) {} return a ? n = a.content : (t.hasAttribute('data-url') ? (n = document.createElement('a')).href = t.getAttribute('data-url') : n = document.createElement('span'), n.textContent = r), n; } }), Prism.hooks.add('complete', t); } }());
!(function () { if (typeof self !== 'undefined' && self.Prism && self.document) if (Prism.plugins.toolbar) { let i = window.ClipboardJS || void 0; i || typeof require !== 'function' || (i = require('clipboard')); const u = []; if (!i) { const t = document.createElement('script'); const e = document.querySelector('head'); t.onload = function () { if (i = window.ClipboardJS) for (;u.length;)u.pop()(); }, t.src = 'https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js', e.appendChild(t); }Prism.plugins.toolbar.registerButton('copy-to-clipboard', (t) => { const e = document.createElement('button'); e.textContent = 'Copy', e.setAttribute('type', 'button'); const o = t.element; return i ? n() : u.push(n), e; function n() { const t = new i(e, { text() { return o.textContent; } }); t.on('success', () => { e.textContent = 'Copied!', r(); }), t.on('error', () => { e.textContent = 'Press Ctrl+C to copy', r(); }); } function r() { setTimeout(() => { e.textContent = 'Copy'; }, 5e3); } }); } else console.warn('Copy to Clipboard plugin loaded before Toolbar plugin.'); }());
